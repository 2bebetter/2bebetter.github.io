<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2bebetter</title>
    <description>to be a better man
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 23 Oct 2020 16:23:22 +0800</pubDate>
    <lastBuildDate>Fri, 23 Oct 2020 16:23:22 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Recent Advances of Resource Allocation in Network Function Virtualization</title>
        <description>&lt;h2 id=&quot;introduction&quot;&gt;introduction&lt;/h2&gt;

&lt;p&gt;随着新的服务模式(如云计算或虚拟现实)的不断出现，以及对网络服务(如高维视频)的服务质量(QoS)要求越来越高，网络上的IP流量呈指数级增长。根据思科[1]的预测，到2021年全球IP流量将达到3.3 ZB，自2016年以来复合年增长率(CAGR)为24%。在传统的网络服务供应范式中，网络功能(如防火墙或负载均衡器)也称为中间件，通常由专用硬件设备实现。由于设计和生产成本较高，部署硬件中间件的成本很高，而且这些中间件需要手动配置和管理，这进一步增加了服务提供商的成本。因此，从资本支出(CAPEX)和运营支出(OPEX)来看，传统的网络服务模式无法满足不断增长的用户QoS要求，这给网络服务提供商带来了很大的挑战。&lt;/p&gt;

&lt;p&gt;网络功能虚拟化(NFV)最初是由欧洲电信标准协会(ETSI)[2]在2012年提出的，现在已经成为一种很有吸引力的解决方案，因为它可以用在虚拟化环境中运行的软件实例来替代专用的硬件设备。在NFV中，所请求的服务由一系列虚拟网络功能(VNF)实现，这些功能可以利用虚拟化技术在通用服务器上运行。这些VNFs按照预定义的顺序排列，数据流通过这些顺序进行遍历，它也称为服务功能链(SFC)。得益于虚拟化技术，可以通过将请求的VNFs以非常高效和敏捷的方式放在网络上来建立SFC。此外，可以以非常低的成本和高效率动态地添加或删除一个或多个VNFs，以应对更改了所请求的SFCs的情况。NFV允许以更可伸缩和弹性的方式分配网络资源，为网络功能提供更高效和灵活的管理和运行机制，从而可以显著降低网络服务提供商的资本支出和运营支出。&lt;/p&gt;

&lt;p&gt;一个重要的问题是我们如何有效地分配网络资源来建立所要求的服务功能链，它主要处理(基本的)VNF放置和流量路由(VPTR)问题及其变体，即将每个用户请求的VNFs放在网络上，在不破坏节点容量和链路带宽的情况下在每个邻近的VNF对之间找到路由。由于NFV的固有特性和设计原则，VPTR问题不同于现有的服务放置和路由问题，虚拟机放置和路由问题。例如，当请求的VNFs被放在网络上时，路由应该按照预定义的顺序逐个遍历每个定位的VNF。此外，在VPTR问题中还需要考虑QoS参数。例如，在一个SFC中，在这个链接中遍历每个VNF的数据包的端到端延迟是衡量NFV性能的重要QoS。为了保证用户满意的网络服务，服务提供商需要向用户承诺对延迟敏感的性能和服务。弹性是NFV的另一个重要的QoS参数，它定义了所提供的服务在面对失败时的生存水平。因为，一旦SFC的一个节点或一个链接出现故障，整个SFC就无法运作，因此所提供的服务就必须停止。当考虑这些QoS参数时，VPTR问题及其变体就变得更加复杂。因此，从不同维度深入了解NFV的资源配置问题是非常重要的，这也是本次调查的重点。&lt;/p&gt;

&lt;p&gt;该篇论文并没有像其它调查一样，从NFV架构和实现、NFV中的资源分配以及它在其它领域中的应用方面提供一个广泛观点，而是针对一个专门的主题：回顾NFV中关于资源分配的最新工作。同时为了简洁，并没有该问题进一步划分。本次调查所回顾的大部分工作在之前的调查工作中都没有涉及到，因此本次调查可以看作是对这些工作的延伸和发展。除此之外，本文还介绍了相关问题的定义和分析，以及相应的解决方法和应用技术，以及主要采用的QoS模型。我们的目的是提供一个详细的回顾，以总结最近的发展和有趣的突破，以解决在NFV中有关的资源配置问题。&lt;/p&gt;

&lt;p&gt;这篇文章的内容组织如下：首先概括和总结了NFV中四个具有代表性的资源分配问题，并分析了它们的特点和复杂性；第3节介绍了NFV资源分配中的时延和可靠性参数的QoS模型。并特别提出一个一般可用性计算模型来定量计算SFC保护的可用性。第4节总结了现有文献，根据不同的QoS参数(如成本、延迟、可靠性、能量)和不同的场景(如边缘云、在线供应、分布式供应)进行分类。第5节讨论一些新出现的主题并指出一些可能的方向。最后，第6节对调查进行了总结。&lt;/p&gt;

&lt;h2 id=&quot;preliminary&quot;&gt;Preliminary&lt;/h2&gt;

&lt;h3 id=&quot;basic-problem-definition-and-analysis&quot;&gt;Basic Problem Definition and Analysis&lt;/h3&gt;

&lt;p&gt;一个网络可以被表示为G(N, L)，N个节点和L个连接。我们用R代表请求集合,一个请求α的集合R(α,F, w)∈R,α表示请求的数据率(所需带宽),F表示有序的VNFs集合,和w= (w1 w2,…,wm)是一个有m个请求的向量(例如,成本、延迟、可用性、能量,等等)。一个VNF f∈F在节点n∈Ψfn所需要的处理时间表示数据包的到达节点n的功能f的处理延迟。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义一：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In a given network G(N,L) and for each request r(α,F,w⃗ )∈R, the VNF Placement and Traffic Routing (VPTR) problem is to place its requested VNFs on N and find routes among each adjacent VNF pair without violating the node capacity and link bandwidth such that the requirement vector w is satisfied.&lt;/p&gt;

&lt;p&gt;给定网络G和请求r，VNF的放置和VPTR问题就是讲请求的VNFs放置在N节点上并且为每一对相邻VNF在不违反节点容量和满足链路带宽的需求向量w的情况下找到路由&lt;/p&gt;

&lt;p&gt;VNF布局(VNFP)问题，不考虑流量路由(sub)问题，定义如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义二：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For a network G(N,L) and a set of requests R, suppose that the path between any node pair in the network is known/given, and each adjacent VNF pair chooses the given path to route the traffic. For each request r(α,F,w)∈R, the VNF Placement (VNFP) problem is to place its requested VNFs on N without violating the node capacity such that w is satisfied.&lt;/p&gt;

&lt;p&gt;对于给定的网络G和请求集合R，假设任意一对节点之间的路径是已知的，并且每一对相邻VNF都会选择给定的路径去转发流量。对于每一个请求r，VNFP问题就是将它请求的VNFs在不超过节点容量和满足向量w的情况下放置在N上&lt;/p&gt;

&lt;p&gt;当请求的VNFs已经被放到网络上时，VPTR问题变成了流量路由(TRR)问题，其定义如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;定义三：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In a given network G(N,L) where a set of existing SFCs are already deployed in the network, the VNF Redeployment and Consolidation (VRC) problem is to redeploy the already existing SFCs such that the requirement vector w is satisfied.&lt;/p&gt;

&lt;p&gt;在给定网络G (N, L)，一组现有的SFCs已经部署在网络中，VNF调动和整合(VRC)问题是重新部署现有SFCs以满足要求向量w。值得注意的是，在虚拟网络嵌入(VNE)[14]问题中，虚拟网络请求(VNR)由一组所需的虚拟节点和虚拟链接组成。VNE问题是将每个VNR映射到基底(物理)网络，以便每个虚拟节点被放置在具有足够容量的不同基底节点上，并为每个虚拟链路分配一条具有足够带宽的路径。虽然VNE问题与VPTR问题有一些相似之处，但有以下不同之处:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在VPTR问题中，SFC中所需的VNFs有一个预定义的顺序，流量必须遍历这个顺序下的每个VNF。相反，在VNE问题中，请求的虚拟节点之间没有必要的顺序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以在VPTR问题的一个节点中放置一个或多个所需的VNFs，但是，VNE问题中的每个请求的虚拟节点必须映射到不同的物理节点上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在流量经过一个VNF进行处理后，它的速率可能在VPTR问题中发生改变(增加或减少)。然而，在VNE问题中，不同虚拟节点对之间的流量率基本保持不变&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;在线和离线配置&lt;/em&gt;。通常,在离线配置方案中,R是事先给定的,我们的目标是基于R设计最优解。相反，在在线配置方案中，假设R中的请求以在线的方式到达网络，我们必须处理一个接一个的请求，因为我们没办法获知未来的请求。除非另有说明，在本次调查中默认采用离线供应方案。在4.6节中，该论文将会讨论NFV中用于在线供应方案的资源分配问题。&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;examples&lt;/h3&gt;

&lt;p&gt;使用下图中的一个例子来描述VPTR问题。图1中的网络有5个节点(包括进入节点和出口节点)，节点a、节点b、节点c的容量分别为8、11、15。链接的容量在链接上方显示。假设一个请求r请求一个SFC，顺序是f1−f2−f3−f4，该订单由4个VNFs组成，其资源需求分别为8、6、14和5。我们必须像网络中所示的那样将这些VNFs放在节点上，而不破坏节点的容量。对于r，让α =5 Mb/s，则该SFC中的整个路由是：进入→a→b→c→b→出口，且不破坏每个遍历链路的容量。我们注意到，这个路由并不是简单路径，因为它包含一个循环。从这个例子中，我们可以看到，遍历整个SFC的路由不一定是简单的路径，这使得VPTR问题更加复杂。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/yang1-3017001-small.gif&quot; alt=&quot;yang1-3017001-small&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来从一个示例开始说明VRC问题。假设有2个请求，其中r1请求的SFC为f1 - f3, r2请求的SFC为f1 - f2。在图中，原本放置在a、b和c上的f1、f2和f3为这两个请求提供服务。经过整合和重新部署，f3从c迁移到b，我们关闭了c&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/yang2-3017001-small.gif&quot; alt=&quot;yang2-3017001-small&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem-goals&quot;&gt;Problem Goals&lt;/h3&gt;

&lt;p&gt;到目前为止，我们在2.1节中正式定义了VPTR问题及其变体，并在2.2节中通过示例描述了这些问题。然而，我们没有提到这些问题的问题目标。例如，除了为VPTR问题找到可行的VNF布局和路由解决方案之外，要实现的问题目标是什么?我们可以将问题目标理解为优化问题的目标函数。以下是经常使用的问题目标:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Maximum link utilization (MLU)&lt;/em&gt;：其链接利用率(ul)被定义为$ v (l) \div c (l) $ ，其中v (l)表示的l中的实际穿越流，c (l)表明l的总容量。一个网络的最大链路利用率是其所有链路的最大链路利用率。目标是使MLU最小化。有时，也使用MLU的倒数，这被称为网络吞吐量，在这些情况下，最大化网络吞吐量相当于最小化MLU。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;QoS parameters&lt;/em&gt;：QoS的主要参数包括服务时延、可用性、能耗等。这些参数可以定量地反映NFV服务提供给客户的程度。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Costs and Revenue&lt;/em&gt;：主要用于网络运营商，它表示在节点上部署VNFs和在使用的链接之间路由流量的操作支出。而收入则是指在容量约束条件下，通过满足流量需求而获得的净收益。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problem-formulation&quot;&gt;Problem Formulation&lt;/h3&gt;

&lt;p&gt;在本节中，我们将全有序SFC中的(基本)VPTR问题2表示为整数非线性规划[16]。我们从一些必要的符号和变量开始:&lt;/p&gt;

&lt;p&gt;$f_i$和$f_j$:SFC中连续两个VNFs。&lt;/p&gt;

&lt;p&gt;$X^{f,r}_n$ ：一个布尔变量，如果请求r的VNF f放在节点n∈n上，则返回1，否则返回0&lt;/p&gt;

&lt;p&gt;$Y_{f_i,f_j,r}^{(u,v)}$ ：一个布尔变量，如果请求r的VNFs fi和fj之间的流遍历link (u,v)，则返回1，否则返回0。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{equation*} \sum _{(u,v) \in \mathcal {L}} Y_{f_i,f_j,r}^{(u,v)}=1 ~~ v \in \mathcal {N}: X^{f_j,r}_v=1 \&amp;\&amp; X^{f_i,r}_v \ne 1, r \in R \quad\quad \tag{2} \end{equation*} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Placement Constraint.&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{equation*} \sum _{n \in \mathcal {N}} X^{f,r}_n = 1~~ \forall r \in R, f \in r. \tag{4} \end{equation*}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Link Capacity Constraint.&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{equation*} \sum _{r(\alpha, F, \vec{w}) \in R, (f_i,f_j) \in r} Y_{f_i,f_j,r}^{(u,v)} \cdot \alpha \leq c(u,v)~~\forall (u,v) \in \mathcal {L}. \tag{5} \end{equation*}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Node Processing Capacity Constraint.&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{equation*} \sum _{r(\alpha, F, \vec{w}) \in R, f \in r} X^{f,r}_n \cdot \eta (f) \leq \pi (n) ~~ \forall n \in \mathcal {N}. \tag{6} \end{equation*}&lt;/script&gt;

&lt;p&gt;这个公式没有目标(需要)，但我们可以加上最小化，例如，节点或链接的数量，总成本等，这取决于特定的网络必需品。方程式(1)、(2)和(3)是流守恒约束，负责从源到目的地的路由并且确保找到一条从u到v的路径。更特别，Eq(1)确保如果fi放在节点u和fj没有放在节点u上，从u出站的流量的总和等于1。Eq(2)保证fj放置在节点v上而fi没有放置在节点v上，则v的传入流量之和为1。Eq(3)保证如果fi和fj不在节点v上，则v的输入流量和v的输出流量相等。Eq(4)保证每个所需的VNF f必须放置在网络中的一个节点上。Eq.(5)保证每个链路上分配的总带宽不超过其最大容量，用c(u,v)表示。Eq(6)保证每个节点分配的总处理能力不超过其最大处理能力，其中，$\eta (f)$表示f所需要的资源，而$\pi (n)$表示节点n的总可用资源。&lt;/p&gt;

&lt;p&gt;当$X^{f,r}&lt;em&gt;n$或$Y&lt;/em&gt;{f_i,f_j,r}^{(u,v)$为输入时，上述INLP相应改变以解决TRR问题或VNFP问题。为了解决VRC问题，设置在R中已经提供了(一些)请求，这些请求已经被在节点上放置了所需的VNFs并选择了适当的路径。在此基础上，我们可以在方程式中1、2、3、4、5、6上运行INLP求解。也就是说，方程式1、2、3、4、5和6相当general。同样值得提及的是，方程式(1)、(2)、(3)、(4)、(5)、(6)解决了一般网络中基本的VPTR问题，不考虑QoS要求，如成本、时延、可用性、能量等。但是，我们可以将这个公式扩展到通过考虑不同网络架构下的QoS要求来解决VPTR问题。为简单起见，延迟感知和可用性感知的VPTR问题公式参见[16]，能量感知的VPTR问题公式参见[19]。此外，VPTR问题的公式并不是我们上面所说的唯一的，只要稍微改变问题的输入就会导致不同的公式。例如，假设给定网络中每个节点对之间的一组路径，则VPTR问题公式与方程式(1)，(2)，(3)不同，因为在这个场景中不存在多社区路由约束。然而，由于INLP具有指数运行时间，它不能在合理的时间内返回一个解，特别是当问题规模很大时，这就需要多项式运行时间近似算法或有效的启发式来解决这个问题。&lt;/p&gt;

&lt;h3 id=&quot;mainly-adopted-approaches&quot;&gt;Mainly Adopted Approaches&lt;/h3&gt;

&lt;p&gt;正如我们在本调查中总结的，处理NFV资源分配最常见的方法包括组合优化理论(如随机/LP舍入、原对偶近似)、深度强化学习、博弈论等。下面，我们将简要介绍具有代表性的方法及其描述：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Randomized/LP rounding：首先将求解问题作为一个整数线性规划公式，然后计算该整数线性规划松弛问题的最优分式解。然后，将LP的分式解整取为原始问题的整数解，使之与最优解保持一定距离。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Primal-Dual approximation：原对偶方法(或原对偶模式)是求解线性程序的另一种方法。该方法的基本思想是从对偶规划的一个可行解y开始，然后试图找到满足互补松弛条件的原始规划的一个可行解x。如果找不到这样一个x，我们就找不到一个更好的客观值y。然后，开始另一个迭代。同时构造了原始IP的近似解和对偶LP的可行解，并逐步改进。最后将近似解与对偶可行解进行比较，估计出近似比。&lt;/li&gt;
  &lt;li&gt;Markov Approximation：首先推导出一个组合问题的最优值的对数和exp逼近，从而得到一个可由时间可逆马尔科夫链实现的解。在这类马尔可夫链中，某些精心设计的马尔可夫链可以产生近似求解网络优化问题的分布式算法。&lt;/li&gt;
  &lt;li&gt;Local Search：局部搜索通过应用局部变化在候选解的空间(搜索空间)中从一个解移动到另一个解，直到找到一个被认为是最优的解或经过了一定的时间限制。&lt;/li&gt;
  &lt;li&gt;Alternating Direction Method of Multipliers (ADMM)：首先将目标和变量分离为两部分，然后对占其中一部分目标的一组变量进行交替优化，迭代达到最优。&lt;/li&gt;
  &lt;li&gt;Column Generation：它从问题的一小部分作为受限主问题(RMP)开始，然后通过分析该部分解决方案来发现问题的下一部分来解决该部分。在此之后，向模型中添加一个或多个变量，然后解析放大后的模型。这个过程重复进行，直到整个问题得到满意的解决方案。&lt;/li&gt;
  &lt;li&gt;Generalized Benders Decomposition (GBD)：在广义弯折分解(GBD)中，原问题被投影到第一阶段变量的空间中，并重新表述为一个包含无限个约束的对偶问题，然后将其松弛为一个包含这些约束的有限子集的下界问题。在将第一阶段变量固定为下界问题的解之后，原始问题就变成了上界问题，对于每一个场景，上界问题都可以自然地分解为更小的子问题。一类上界问题的解给出了目标函数最优值上的一个非递减上界，一类下界问题的解给出了一个非递增的下界。当上界和下界收敛时，得到原问题的一个最优解。&lt;/li&gt;
  &lt;li&gt;Deep Reinforcement Learning (DRL)：DRL是一种解决决策问题的方法，它结合了强化学习(RL)的思想和深度学习(DL)的结构。RL的本质是通过与环境的试错交互来学习。RL代理首先感知环境的状态，然后根据当前状态选择操作。到达新状态后，代理会收到与新状态相关联的奖励。获得的奖励会告诉特工所采取的行动是好是坏。代理的目的是寻找最优策略。策略是agent根据当前状态来决定下一步行动，从而使回报最大化的策略。DL在DRL中的作用是利用神经网络强大的表示能力来适应RL agent的策略，例如处理复杂动态环境中的问题。&lt;/li&gt;
  &lt;li&gt;Game theory：博弈论是研究竞争对手之间战略互动的理论模型。它通常用于解决在存在竞争、合作或冲突的情况下为每个玩家选择最优决策的问题。一个博弈模型通常由两个或两个以上的参与者、一组策略和效用函数组成。一般而言，独立做出决定的玩家可能是恶意的、合作的或自私的，而玩家的成功决策取决于他人的选择。在博弈论中，玩家轮流与其他对手竞争以最大化他们的收益，直到他们达到纳什均衡(NE)。NE是一种稳定状态，在这种状态下，在考虑了其他对手的选择后，没有玩家会有偏离自己选择的策略的动机。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常，随机/LP舍入、原对偶和马尔可夫近似技术用于设计近似算法。局部搜索方法有助于加快寻找局部最优解的速度，但不能保证能找到全局最优解，因此它是一种启发式解。ADMM、列生成和GBD在实际应用中可以快速收敛到最优解，但理论上仍具有指数运行时间。DRL为解决组合优化问题(如NFV资源分配问题)提供了一个新的视角，但DRL具有不确定的收敛时间和较长的训练时间。博弈论提供了一个分布式的方式在NFV解决资源分配问题,但由于由于缺乏全球网络信息，实质上它不能解决资源配置问题NFV为了得到最优解，以及考虑更多的QoS参数如延迟和可用性。&lt;/p&gt;

&lt;h2 id=&quot;qos-models-in-nfv&quot;&gt;QoS Models in NFV&lt;/h2&gt;

&lt;p&gt;时延和可用性是NFV服务中两个重要的QoS参数，本文研究了一般情况下NFV中如何定量计算时延和可用性。此外，我们还提供了一个VNF位置可用性计算模型，该模型也可以在[16]中看到。其他的QoS模型将在第4节提到相应的文献时进行介绍，因为其简单性和与本节介绍的模型的相似性。&lt;/p&gt;

&lt;h3 id=&quot;delay-calculation-of-an-sfc&quot;&gt;Delay Calculation of an SFC&lt;/h3&gt;

&lt;p&gt;根据函数链的特点,有三种VNFs之间的依赖关系,即(1)non-ordered: VNFs之间没有依赖关系,(2)完全有序:有一个总依赖秩序VNF集,和(3)半序:VNFs的子集之间存在依赖关系。遍历时延的计算主要依赖于全有序场景和部分有序场景，因为实际中无序场景并不经常发生。下图显示了一个完全有序的SFC：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/yang3-3017001-small.gif&quot; alt=&quot;yang3-3017001-small&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们假设一个SFC包含一组|F|个有序VNFs, f1, f2，…，它们需要被放置在网络中。假设|F| VNFs有一个完全依赖顺序，那么一个完全有序的SFC的遍历延迟计算如下:
&lt;script type=&quot;math/tex&quot;&gt;\begin{equation*} \sum _{f \in F, n \in \mathcal {N}} \Psi ^f_n+\sum _{l \in \mathcal {L}^s} d(l). \tag{7} \end{equation*}&lt;/script&gt;
其中$ \Psi ^f_n $表示函数f在节点n上的处理延迟，$ \mathcal {L}^s $表示连接这些放置的VNF的链路集，d(l)表示在链路l上传递延迟的流。&lt;/p&gt;

&lt;p&gt;然而，由于监控功能实际上只维护数据包而不更改数据包，这表明防火墙和监控功能并不相互依赖。从这个意义上讲,这两个函数可以工作在两种情况下,即(1)在SFC中，它们以任意顺序工作；(2)他们在SFC并行工作。(1),ingress-a-c-b-d-egress也是一个可行的的SFC选择。在case(2)中，防火墙与监控并行工作，如图3b所示。之后，防火墙和监控功能将各自处理过的数据包发送到负载均衡器。因此，负载均衡器只需要从防火墙中选择数据包并处理它们。因此，可能存在多条数据路由在部分有序链中从入口节点到出口节点进行遍历。因此，并行SFC的遍历时延等于最长时延路由，即该数据传递路由的节点时延和链路时延之和最大。例如，图3b中的SFC遍历时延等于路径ingress→a - c - d→egress，其时延为50+10+80+25+60=225 ms，小于图3a中的时延。很明显，与完全有序的延迟相比，部分有序的SFC可以缩短服务延迟，但这是以消耗更多链路带宽为代价的。因此，使用全有序SFC还是部分有序SFC，取决于网络预算和应用需求的权衡。&lt;/p&gt;

&lt;p&gt;从上面的例子中我们可以看到，给定一个必需的非有序链，就会存在多个可能的SFCs(顺序的或并行的)。我们把产生这种可能的SFCs的过程称为链组成问题。图3也称为SFC转发图。在本次调查中，我们假设在NFV中，将SFC转发图输入到资源分配问题中，因此我们没有解决链组成问题。&lt;/p&gt;

&lt;h3 id=&quot;nfv-resilience&quot;&gt;NFV Resilience&lt;/h3&gt;

&lt;p&gt;弹性是NFV的另一个重要的QoS参数，它定义了所提供的服务在面对失败时的生存水平。因为，一旦SFC的一个节点或一个链接出现故障，整个SFC就无法运作，所提供的服务就必须停止。解决这个问题的一个有效方法是提供冗余的SFCs，这些SFCs通常将请求的VNFs放置在不同的节点上以防止节点故障(称为node-disjoint)或选择不遍历同一链接的路径(称为link-disjoint)来克服链路故障。这样，服务通常由主SFC提供，当主SFC出现节点/链路故障时，备用SFC将被激活以工作。这种方法也被称为SFC保护。&lt;/p&gt;

&lt;p&gt;Hmaity等研究了三种情况下的SFC保护，即:(1)端到端保护:一个主SFC和一个备用SFC（节点和链路都是不相交的）;(2)链路保护;(3)节点保护。下图反映了在网络中放置3个VNFs的三种保护方案，其中红线表示主路径，蓝线表示备份路径&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/yang4-3017001-small.gif&quot; alt=&quot;yang4-3017001-small&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而，Hmaity等人提出的SFC保护方案没有考虑节点和链路的失效概率。例如，如果主SFC和备份SFC都包含故障概率较高的节点或链接，那么这种保护也不能保证可靠的服务。此外，在这种方法中，仅考虑k=2个SFCs的保护(即一个VNF副本)。但在实际应用中，为了提供更可靠的服务，我们有时需要提供k≥2个SFCs。为了解决这个问题，我们基于图4中提出的保护方案，提出了一个定量模型来计算VNF的布置可用性。与[30]类似，我们考虑节点和链接的可用性，以定量测量任何k≥1 VNF副本/备份的SFC保护的可靠性。更具体地说，系统的可用性是系统在整个服务时间内运行的时间所占的比例。网络组件j的可用性Aj可以计算为:
&lt;script type=&quot;math/tex&quot;&gt;\begin{equation*} A_{j}=\frac{MTTF}{MTTF+MTTR}, \tag{8} \end{equation*}&lt;/script&gt;
式中，MTTF表示平均故障时间，MTTR表示平均修复时间。网络中的节点表示服务器，而链路表示连接两个物理服务器的物理链路。它们的可用性等于其所有组件(例如，节点的硬盘和内存，链路的放大器和光纤)可用性的乘积。对于一个服务器n，设a (n)和p(n)分别表示其可用性值和故障概率，则有a (n)=1−p(n)。节点故障可能因服务器年龄、硬盘数量等不同而不同，它们可能是由硬件组件故障、软件bug、电源丢失事件等引起的。实际上，我们可以通过访问记录服务器生命周期中每个硬件组件修复/故障事件的详细日志来获得服务器的可用性值。描述服务器故障和统计计算节点可用性的细节可以在[32]，[33]和其中的论文中找到。参考[34]和其中的论文提供了数据中心中其他网络设备(如交换机)的故障统计。&lt;/p&gt;

&lt;p&gt;我们区分并分析了两种不同情况下的VNF放置可用性，即:(1)不受保护的SFC:只允许在网络中放置一个SFC;(2)受保护的SFC:网络中最多可以放置k≥2个SFCs。&lt;/p&gt;

&lt;p&gt;假设一个不受保护的SFC将VNFs放在w个节点n1, n2，…， nw，遍历m个连接l1, l2，…， lm，其可用性计算为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{equation*} \prod _{i=1}^w A_{n_i} \cdot \prod _{j=1}^m A_{l_j}, \tag{9} \end{equation*}&lt;/script&gt;

&lt;p&gt;其中$\prod &lt;em&gt;{i=1}^w A&lt;/em&gt;{n_i}$表示所有节点的可用性，$\prod &lt;em&gt;{j=1}^m A&lt;/em&gt;{l_j}$表示所有遍历链接的可用性&lt;/p&gt;

&lt;p&gt;在受保护的SFC中，我们强调它是由(最大)k个不受保护的SFCs组成。为便于澄清，我们进一步将受保护放置中k不受保护的SFC分别称为placement组$p_i$。我们用第一个放置组表示。因为不同的放置组可能将一个或多个VNFs放在相同的节点和/或遍历链接，我们将保护放置分为两种情况,即(1)完全保护SFC：k放置组的每一个都把VNF放置在不同的节点、遍历不同的链接和(2)部分保护SFC：至少两个放置组在相同的节点上放置一个或多个VNFs或遍历相同的链接。在完全保护的放置情况下，可用性可以计算为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{equation*} 1-\prod _{i=1}^k(1-A_{\rho _i}). \tag{10} \end{equation*}&lt;/script&gt;

&lt;p&gt;式(10)表示k个SFCs的可用性等于至少有一个SFC能够正常工作(不失败)的概率。例如，在图5a中，节点和链接的可用性是相关联的，我们使用s和d来表示进入和出口节点。为了便于表达，它们的可用性总是1。SFC的s-a-b-d和s-c-g-d是完全保护的，因为它们不包含任何相同的链路或节点。因此，这两种SFCs的总可用性为:&lt;/p&gt;

&lt;p&gt;1−(1−0.9⋅0.99⋅0.8⋅0.85⋅0.95)⋅(1−0.95⋅0.98⋅0.75⋅0.99⋅0.88)≈0.8338&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/yang5-3017001-small.gif&quot; alt=&quot;yang5-3017001-small&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/yang6-3017001-small.gif&quot; alt=&quot;yang6-3017001-small&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们考虑一个一般的场景，其中至少有两个k放置组将相同的VNF放置在相同的节点上，或者遍历相同的链接。在这种情况下，Eq.(10)不能用于计算这种情况下的可用性，因为重叠节点或链接的可用性将被多次计算。为了修正这一点，我们使用新的operator∘。假设有m个不同节点n1,n2，…，nm，可利用度An1,An2，…，Anm。对于具有可用性和Anx的节点，∘可定义为:&lt;/p&gt;

&lt;p&gt;在此，连接可用性的∘计算可被类似地定义。&lt;/p&gt;

&lt;p&gt;让∐表示连续∘操作的不同,交换,关联和分配。因此，k个部分保护的SFCs的可用性现在可以表示为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*} &amp;1-\coprod _{i=1}^{k} (1-A_{\rho _{i}}) \\ =&amp;1- (1-A_{\rho _{1}})\circ (1-A_{\rho _{2}}) \circ \cdots \circ (1-A_{\rho _{k}}) \\ =&amp;\sum _{i=1}^{k}A_{\rho _{i}}-\sum _{0&lt;i&lt;j\leq k} A_{\rho _{i}} \circ A_{\rho _{j}}+ \\ &amp;\sum _{ 0&lt;i&lt;j&lt;u \leq k}A_{\rho _{i}} \circ A_{\rho _{j}} \circ A_{\rho _{u}}+\cdots +(-1)^{k-1}\coprod _{i=1}^{k}A_{\rho _{i}}, \tag{12} \end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;式中$A_{p_i}$表示安置组的可用性，可由式(9)计算，以图5b为例。SFCs s-a-b-d和s-c-b-d部分受到保护，因为它们共同将VNF f2放在节点b上，并且它们也通过相同的链路(b,d)。因此，总可用性计算为&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-thesis-reading-01/image-20201023152536021.png&quot; alt=&quot;image-20201023152536021&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;resource-allocation-in-nfv&quot;&gt;Resource Allocation in NFV&lt;/h2&gt;

&lt;p&gt;在本节中，我们调查了有关根据不同QoS参数(如成本、延迟、可用性、能量)进行资源分配的文献。我们还调查了有关边缘云、在线和分布式供应方案的相关文献。在每个类别(分段)中，我们在第2.1节基于四个广义资源分配问题进一步调查了文献，它们是VPTR问题，VNFP问题，TRR问题和VRC问题。我们以讨论结束每个小节。&lt;/p&gt;

&lt;h3 id=&quot;cost-aware-resource-allocation&quot;&gt;Cost-Aware Resource Allocation&lt;/h3&gt;

&lt;p&gt;在本节中，我们调查了关于NFV中成本意识资源分配的文献。这是NFV中最基本和最基本的资源分配问题，其问题公式见第2.4节。&lt;/p&gt;

&lt;h4 id=&quot;vptr-problem&quot;&gt;VPTR Problem&lt;/h4&gt;

&lt;p&gt;Ma等人[35]研究了最小化最大链路负载的VPTR问题。通过简化为np-hard哈密顿循环问题[36]，证明了即使在非有序VNF依赖情况下，VPTR问题也是np难的。Ma等人[37]随后提出了一种基于LFGL的最小最大路由算法来解决VPTR问题，并在支持sdn的环境中实现了该算法。在非有序VNF依赖的情况下，Cohen等人[38]提出了一种使用舍入技术的近最优逼近算法来解决VPTR问题，使系统总代价最小化。[38]中的系统总成本包括放置在节点n上的函数f的设置成本，以及客户端与获得服务的节点之间距离的总和。Ghaznavi等人[39]建议在多个节点上分配VNF请求的实例，以最小化链路负载比(或最大化吞吐量)。他们随后提出了一种局部搜索启发式算法，该算法采用了一种调整参数来平衡速度和精度之间的权衡，从而解决了VPTR问题。Spinnewyn等人[40]在VPTR问题中联合考虑了部分有序链和位置约束。他们首先将问题表示为一个基于扩展VNF树的ILP，并预先计算出满足优先级要求的SFCs。在此基础上，提出了一种基于贪心链选择和嵌入的启发式算法。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Oct 2020 12:51:40 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/2020/10/21/thesis-reading-01.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/2020/10/21/thesis-reading-01.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>Your first blog</title>
        <description>&lt;h1 id=&quot;first-post使用githubio和jekyll搭建个人博客&quot;&gt;First Post——使用github.io和jekyll搭建个人博客&lt;/h1&gt;

&lt;p&gt;由于最近可能会阅读一些论文，因此决定搭建一个个人博客用以记录论文阅读过程中可能会产生的笔记，而CSDN的博客我个人不太喜欢，又由于自己的囊中羞涩，最后决定使用github.io结合jekyll搭建一个博客。&lt;/p&gt;

&lt;h2 id=&quot;配置环境&quot;&gt;配置环境&lt;/h2&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;jekyll&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;install&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为win10内嵌了linux子系统，而使用linux安装jekyll个人觉得要比windows系统相对来说更为容易，因此决定在该linux子系统内配置环境。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt install ruby jekyll&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ol&gt;
  &lt;li&gt;new project&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;jekyll new helloworld

&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;helloworld

jekyll serve&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;githubio&quot;&gt;github.io&lt;/h3&gt;

&lt;h4 id=&quot;create-a-repository&quot;&gt;Create a repository&lt;/h4&gt;

&lt;p&gt;在GitHub中创建一个名为username.github.io的新仓库，其中username是你在GitHub上的用户名&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-personal-blog/image-20201020190937302.png&quot; alt=&quot;image-20201020190937302&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;clone-the-repository&quot;&gt;Clone the repository&lt;/h4&gt;

&lt;p&gt;转到要存储项目的文件夹，然后克隆这个仓库：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;git clone https://github.com/username/username.github.io&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;hello-world&quot;&gt;Hello world&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;username.github.io

&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;Hello, world&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; index.html&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;personal-blog&quot;&gt;Personal Blog&lt;/h3&gt;

&lt;h4 id=&quot;run-the-first-blog&quot;&gt;Run the first blog&lt;/h4&gt;

&lt;p&gt;目前有很多的jekyll主题和模板，在这里提供一个网站&lt;a href=&quot;http://jekyllthemes.org/&quot;&gt;jekyll themes&lt;/a&gt;和一个教程：&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io/blob/master/_doc/README.zh.md&quot;&gt;说明文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我个人选择了&lt;a href=&quot;http://jekyllthemes.org/themes/monos/&quot;&gt;monos&lt;/a&gt;这个主题，下载该主题后解压到你的项目文件夹下，运行之后会出现一些依赖不存在的情况，只需要按照它所提示的名称和版本安装即可&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;username:/jekyll-theme-monos-master&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;jekyll-theme-monos-master

username:/jekyll-theme-monos-master&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;jekyll serve

Traceback &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;most recent call last:

  10: from /usr/bin/jekyll:7:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&amp;lt;main&amp;gt;&lt;span class=&quot;s1&quot;&gt;&#39;

  9: from /usr/lib/ruby/vendor_ruby/jekyll/plugin_manager.rb:33:in `require_from_bundler&#39;&lt;/span&gt;

  8: from /usr/local/lib/site_ruby/2.5.0/bundler.rb:149:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;setup&lt;span class=&quot;s1&quot;&gt;&#39;

  7: from /usr/local/lib/site_ruby/2.5.0/bundler/runtime.rb:20:in `setup&#39;&lt;/span&gt;

  6: from /usr/local/lib/site_ruby/2.5.0/bundler/runtime.rb:101:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;block &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;definition_method&lt;span class=&quot;s1&quot;&gt;&#39;

  5: from /usr/local/lib/site_ruby/2.5.0/bundler/definition.rb:226:in `requested_specs&#39;&lt;/span&gt;

  4: from /usr/local/lib/site_ruby/2.5.0/bundler/definition.rb:237:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;specs_for&lt;span class=&quot;s1&quot;&gt;&#39;

  3: from /usr/local/lib/site_ruby/2.5.0/bundler/definition.rb:170:in `specs&#39;&lt;/span&gt;

  2: from /usr/local/lib/site_ruby/2.5.0/bundler/spec_set.rb:80:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;materialize&lt;span class=&quot;s1&quot;&gt;&#39;

  1: from /usr/local/lib/site_ruby/2.5.0/bundler/spec_set.rb:80:in `map!&#39;&lt;/span&gt;

/usr/local/lib/site_ruby/2.5.0/bundler/spec_set.rb:86:in &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;block &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;materialize&lt;span class=&quot;s1&quot;&gt;&#39;: Could not find public_suffix-4.0.3 in any of the sources (Bundler::GemNotFound)

username:/jekyll-theme-monos-master$ sudo gem install bundler:1.17.2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;安装过程中可能会出现如下的错误，安装ruby-dev&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;username:/jekyll-theme-monos-master&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gem install eventmachine &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; 1.2.7

Building native extensions. This could take a &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;...               

ERROR: Error installing eventmachine:

  ERROR: Failed to build gem native extension.

current directory: /var/lib/gems/2.5.0/gems/eventmachine-1.2.7/ext

/usr/bin/ruby2.5 &lt;span class=&quot;nt&quot;&gt;-I&lt;/span&gt; /usr/local/lib/site_ruby/2.5.0 &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; ./siteconf20201020-5764-1v6qrrl.rb extconf.rb  

mkmf.rb can&lt;span class=&quot;s1&quot;&gt;&#39;t find header files for ruby at /usr/lib/ruby/include/ruby.h

​    extconf failed, exit code 1

Gem files will remain installed in /var/lib/gems/2.5.0/gems/eventmachine-1.2.7 for inspection.   

Results logged to /var/lib/gems/2.5.0/extensions/x86_64-linux/2.5.0/eventmachine-1.2.7/gem_make.out 

username:/jekyll-theme-monos-master$ sudo apt install ruby-dev&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h4 id=&quot;markdown编译器&quot;&gt;markdown编译器&lt;/h4&gt;

&lt;p&gt;我的第一篇博客如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-personal-blog/image-20201021092055720.png&quot; alt=&quot;image-20201021092055720&quot; /&gt;&lt;/p&gt;

&lt;p&gt;感觉样式被解析的十分奇怪，这是因为jekyll的markdown语法和github，或简书上的markdown语法很不一样，比如代码高亮部分只能用以下形式:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-personal-blog/image-20201021104402448.png&quot; alt=&quot;image-20201021104402448&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们查看配置文件时，发现&lt;code class=&quot;highlighter-rouge&quot;&gt;Jekyll&lt;/code&gt;使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;解析器是默认使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;kramdown&lt;/code&gt;，我们可以将其修改为我们需要的markdown解析器，jekyll支持三种markdown解析器：kramdown,redcarpet,rdiscount，同时我们可以通过在&lt;strong&gt;&lt;em&gt;*_config.yml*&lt;/em&gt;&lt;/strong&gt;文件中修改&lt;code class=&quot;highlighter-rouge&quot;&gt;markdown: kramdown&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;kramdown:[]&lt;/code&gt;修改markdown解析器的默认设置。&lt;/p&gt;

&lt;p&gt;Github Pages在今年宣布开始使用Jekyll 3.0, 导致的变化有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;将只支持kramdown作为Markdown引擎&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将只支持Rouge作为Markdown代码语法高亮&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大幅提升构建速度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不再支持Permalinks和Textile&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以之前的配置方法现在不再适用，我们需要对Jekyll的相应配置重新进行修改。&lt;/p&gt;

&lt;h4 id=&quot;配置github&quot;&gt;配置github&lt;/h4&gt;

&lt;p&gt;在你的github仓库中修改settings设置，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-personal-blog/image-20201021101011843.png&quot; alt=&quot;image-20201021101011843&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当出现提示“Your site is ready to be published at http://2bebetter.github.io”时，配置成功。&lt;/p&gt;

&lt;h4 id=&quot;插入图片&quot;&gt;插入图片&lt;/h4&gt;

&lt;p&gt;我使用的markdown编辑器是typora，插入图片时非常方便，但是不能正确在github上显示，修改typora和配置文件如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;typora&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;偏好设置-&amp;gt;图像-&amp;gt;图像插入时，选择”复制到指定位置”并将地址设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;../img/${filename}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2020-10-21-personal-blog/image-20201021103739381.png&quot; alt=&quot;image-20201021103739381&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;jekyll&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在每一篇post的开头配置行中加入&lt;code class=&quot;highlighter-rouge&quot;&gt;typora-root-url: ..&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样插入图片的时候，就会自动在_post平级的img文件下面生成一个与post同名的文件夹并放入名称类似&lt;code class=&quot;highlighter-rouge&quot;&gt;../img/in-post/post_name/picture_name.png&lt;/code&gt;的图片,通过&lt;code class=&quot;highlighter-rouge&quot;&gt;/img/post_name/picture_name.png&lt;/code&gt;引用图片的时候typora会去找&lt;code class=&quot;highlighter-rouge&quot;&gt;../img/post_name/picture_name.png&lt;/code&gt; 能够预览图片，在github pages时&lt;code class=&quot;highlighter-rouge&quot;&gt;typora-root-url: ..&lt;/code&gt; 无效，找的还是&lt;code class=&quot;highlighter-rouge&quot;&gt;/img/post_name/picture_name.png&lt;/code&gt;，能够正确显示图片。&lt;/p&gt;

&lt;h4 id=&quot;数学公式&quot;&gt;数学公式&lt;/h4&gt;

&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;

&lt;p&gt;plugin：&lt;a href=&quot;https://github.com/jossets/jekyll-toc&quot;&gt;jossets/jekyll-toc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这种方法可以兼容github-page：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A GitHub Pages compatible Table of Contents generator without a plugin or JavaScript :octocat: https://pure-liquid.allejo.org/&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载最新的&lt;a href=&quot;https://github.com/jossets/jekyll-toc/blob/master/_includes/toc.html&quot;&gt;toc.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;将该文件拖进_includes文件夹下&lt;/li&gt;
  &lt;li&gt;在模板布局页面中&lt;code class=&quot;highlighter-rouge&quot;&gt;{\{ content \}}&lt;/code&gt;前加入：&lt;code class=&quot;highlighter-rouge&quot;&gt;\{\% include toc.html html=content \%\}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 21 Oct 2020 10:21:40 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/2020/10/21/personal-blog.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/2020/10/21/personal-blog.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Tom&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Oct 2020 20:05:40 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/update/2020/10/20/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/update/2020/10/20/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
